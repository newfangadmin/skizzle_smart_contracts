pragma solidity ^0.5;
pragma experimental ABIEncoderV2;

import './SafeMath.sol';

contract NewfangDIDRegistry {
    using SafeMath for uint;
    bytes32 public log;

    // keccak256(storage index) => bytes32 newfang-specific-idstring
    mapping(bytes32 => string) public owners; // file owners
    // file id => access type => user => access control key
    mapping(bytes32 => mapping(bytes32 => mapping(string => ACK))) public accessSpecifier;
    mapping(bytes32 => mapping(bytes32 => string [])) public userAccess;
    mapping(address => uint) public changed;
    mapping(string => uint) public nonce;
    mapping(bytes32 => File) public files;
    address public owner;

    struct File {
        uint256 n;
        uint256 k;
        uint256 file_size;
        string ueb;
    }

    struct ACK {// Access Control Key
        uint256 _type; // type of access email or public key
        uint256 validity;
    }

    constructor () public {
        owner = msg.sender;
    }

    modifier onlyFileOwner(bytes32 _file, string memory _identity) {
        require(compareStrings(_identity , owners[_file]));
        _;
    }

    function compareStrings(string memory a, string memory b) internal pure returns (bool) {
        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));
    }


    function toString(address _addr) public pure returns(string memory) {
        bytes32 value = bytes32(uint256(_addr));
        bytes memory alphabet = "0123456789abcdef";

        bytes memory str = new bytes(42);
        str[0] = '0';
        str[1] = 'x';
        for (uint i = 0; i < 20; i++) {
            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];
            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];
        }
        return string(str);
    }



    function remove(address[] memory array, uint index) internal pure returns (address[] memory) {

        for (uint i = index; i < array.length - 1; i++) {
            array[i] = array[i + 1];
        }
        delete array[array.length - 1];
        //        array.length--;
        return array;
    }

    function getSigner(bytes32 payloadHash, string memory signer, uint8 v, bytes32 r, bytes32 s) public pure returns (address){
        bytes32 messageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", payloadHash));
        address actualSigner = ecrecover(messageHash, v, r, s);
        require(compareStrings(signer, toString(actualSigner)));
        return actualSigner;
    }


    /**
    * @dev This function will be used by createDID pubic function and createDIDSigned
    * @return bool
    */
    function createDID(bytes32 _id, string memory _identity) internal returns (bool){
        require(compareStrings(owners[_id], "0x0000000000000000000000000000000000000000"), "Owner already exist for this file");
        owners[_id] = _identity;
        nonce[_identity]++;
        return true;
    }

    /**
    * @dev _id will be the file index which is generated by newfang SDK on client side.
    * @return bool
    */
    function createDID(bytes32 _id) public returns (bool){
        return createDID(_id, toString(msg.sender));
    }

    function createDIDSigned(bytes32 _id, string memory signer, uint8 v, bytes32 r, bytes32 s) public returns (bool) {
        bytes32 payloadHash = keccak256(abi.encode(_id, nonce[signer]));
        address actualSigner = getSigner(payloadHash, signer, v, r, s);
        return createDID(_id, toString(actualSigner));
    }


    function getTotalUsers(bytes32 _file, bytes32 _access_type) public view returns (uint256){
        return userAccess[_file][_access_type].length;
    }

    // function getAllUsers(bytes32 _file, bytes32 _access_type) public view returns (address[] memory){
    //     address[] memory users = userAccess[_file][_access_type];
    //     address user;
    //     for (uint i = 0; i < users.length; i++) {
    //         user = userAccess[_file][_access_type][i];
    //         if (accessSpecifier[_file][_access_type][user].validity <= now) {
    //             //                users = remove(users, i);
    //             delete users[i];
    //         }
    //     }
    //     return users;
    // }


    /**
    * @dev key is encrypted with users public key and stored on a server hash of encrypted key is stored here in smart
     contract along with its validity
    * @return bool
    */
    function share(string memory _identity, bytes32 _file, uint256 _type,string memory _user, bytes32 _access_type, uint256 _validity) internal onlyFileOwner(_file, _identity) returns (bool){
        require(_validity != 0, "Validity must be non zero");
        ACK memory ack = accessSpecifier[_file][_access_type][_user];
        require(ack.validity == 0, "Already shared with user");
        accessSpecifier[_file][_access_type][_user] = ACK(_type, now.add(_validity));
        userAccess[_file][_access_type].push(_user);
        nonce[_identity]++;
        return true;
    }

    //    function share(bytes32 _file, address _user, bytes32 _access_type, bytes32 _access_key, uint256 _validity) public returns (bool){
    //        return share(msg.sender, _file, _user, _access_type, _access_key, _validity);
    //    }


    function shareSigned(bytes32 _file, uint256 _type,string memory _user, bytes32 _access_type, bytes32 _access_key, uint256 _validity, string memory signer, uint8 v, bytes32 r, bytes32 s) public returns (bool) {
        bytes32 payloadHash = keccak256(abi.encode(_file, _user, _access_type, _access_key, _validity, nonce[signer]));
        address actualSigner = getSigner(payloadHash, signer, v, r, s);
        return share(toString(actualSigner), _file, _type,_user, _access_type, _validity);
    }

    function fileUpdate(string memory _identity, bytes32 _file, uint256 n, uint256 k, uint256 file_size, string memory ueb) internal onlyFileOwner(_file, _identity) returns (bool){
        require(compareStrings(owners[_file], "0x0000000000000000000000000000000000000000"), "File does not has an owne");
        require(n > k, "n>k");
        require(file_size != 0, "Should not be 0");
        files[_file] = File(n, k, file_size, ueb);
        return true;
    }

    function fileUpdate(bytes32 _file, uint256 n, uint256 k, uint256 file_size, string memory ueb) public returns (bool){
        return fileUpdate(toString(msg.sender), _file, n, k, file_size, ueb);
    }

    function fileUpdateSigned(bytes32 _file, uint256 n, uint256 k, uint256 file_size, string memory ueb, string memory signer, uint8 v, bytes32 r, bytes32 s) public returns (bool){
        bytes32 payloadHash = keccak256(abi.encode(_file, n, k, file_size, ueb, nonce[signer]));
        address actualSigner = getSigner(payloadHash, signer, v, r, s);
        return fileUpdate(toString(actualSigner), _file, n, k, file_size, ueb);
    }

    event KeyHash(
        uint256 _type,
        uint256 validity
    );

    function getKeyHash(string memory _identity, bytes32 _file, bytes32 _access_type) internal returns (uint256, uint256){
        ACK memory ack = accessSpecifier[_file][_access_type][_identity];
        nonce[_identity]++;
        emit KeyHash(ack._type, ack.validity);
        return (ack._type, ack.validity);
    }


    /**
    * @dev Fetch ACK hash of user
    * @return encrypted hash and validity
    */
    function getKeyHash(bytes32 _file, bytes32 _access_type) public returns (uint256, uint256){
        return getKeyHash(toString(msg.sender), _file, _access_type);
    }

    function getKeyHashSigned(bytes32 _file, bytes32 _access_type, string memory signer, uint8 v, bytes32 r, bytes32 s) public returns (uint256, uint256) {
        bytes32 payloadHash = keccak256(abi.encode(_file, _access_type, nonce[signer]));
        address actualSigner = getSigner(payloadHash, signer, v, r, s);
        return getKeyHash(toString(actualSigner), _file, _access_type);
    }


    function IndexOf(string[] memory values, string memory value) internal pure returns (uint) {
        uint i = 0;
        while (!compareStrings(values[i], value)) {
            i++;
        }
        return i;
    }

    /**
    * @dev Update ACK hash or its validity
    * @return bool
    */
    function updateACK(string memory _identity, bytes32 _file, uint256 _type,string memory _user, bytes32 _access_type, uint256 _validity) internal onlyFileOwner(_file, _identity) returns (bool){
        accessSpecifier[_file][_access_type][_user] = ACK(_type, now.add(_validity));
        if (_validity == 0) {
            delete accessSpecifier[_file][_access_type][_user];
            uint index = IndexOf(userAccess[_file][_access_type], _user);
            delete userAccess[_file][_access_type][index];
        }
        nonce[_identity]++;
        return true;
    }

    function updateACK(bytes32 _file, uint256 _type,string memory _user, bytes32 _access_type, uint256 _validity) public returns (bool){
        return updateACK(toString(msg.sender), _file, _type, _user, _access_type, _validity);
    }

    function updateACKSigned(bytes32 _file, uint256 _type,string memory _user, bytes32 _access_type, uint256 _validity, string memory signer, uint8 v, bytes32 r, bytes32 s) public returns (bool) {
        bytes32 payloadHash = keccak256(abi.encode(_file, _type, _user, _access_type, _validity, nonce[signer]));
        address actualSigner = getSigner(payloadHash, signer, v, r, s);
        return updateACK(toString(actualSigner), _file, _type, _user, _access_type, _validity);
    }



    /**
    * @dev Change file Owner
    * @return bool
    */
    function changeFileOwner(string memory _identity, bytes32 _file, string memory _new_owner) internal onlyFileOwner(_file, _identity) returns (bool){
        require(!compareStrings(_new_owner, "0x0000000000000000000000000000000000000000"), "Invalid address");
        compareStrings(owners[_file], _new_owner);
        nonce[_identity]++;
        return true;
    }

    function changeFileOwner(bytes32 _file, string memory _new_owner) public returns (bool){
        return changeFileOwner(toString(msg.sender), _file, _new_owner);
    }

    function changeOwnerSigned(bytes32 _file, string memory _new_owner, string memory signer, uint8 v, bytes32 r, bytes32 s) public returns (bool) {
        bytes32 payloadHash = keccak256(abi.encode(_file, _new_owner, nonce[signer]));
        address actualSigner = getSigner(payloadHash, signer, v, r, s);
        return changeFileOwner(toString(actualSigner), _file, _new_owner);
    }
}
